<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/server.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server.py" />
              <option name="originalContent" value="import socket&#10;import time&#10;import threading&#10;import protocol&#10;from game_logic import BlackjackGame&#10;from concurrent.futures import ThreadPoolExecutor&#10;import logging&#10;&#10;# --- Logging Setup ---&#10;logging.basicConfig(&#10;    level=logging.INFO,&#10;    format='%(asctime)s [%(threadName)-12s] %(message)s',&#10;    datefmt='%H:%M:%S'&#10;)&#10;logger = logging.getLogger(__name__)&#10;&#10;# --- Network Constants ---&#10;UDP_DEST_PORT = 13122&#10;BROADCAST_IP = '&lt;broadcast&gt;'&#10;TCP_PORT = 0&#10;CLIENT_TIMEOUT = 60&#10;MAX_CONCURRENT_CLIENTS = 10  # Thread pool size&#10;&#10;# --- Global Statistics (Thread-Safe) ---&#10;active_players = 0&#10;active_players_lock = threading.Lock()&#10;&#10;# --- Thread Pool ---&#10;thread_pool = ThreadPoolExecutor(max_workers=MAX_CONCURRENT_CLIENTS, thread_name_prefix=&quot;ClientHandler&quot;)&#10;&#10;&#10;def get_local_ip():&#10;    &quot;&quot;&quot;&#10;    Attempts to find the actual local IP address of the machine.&#10;    &quot;&quot;&quot;&#10;    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)&#10;    try:&#10;        # Create UDP socket&#10;        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)&#10;        s.connect((&quot;8.8.8.8&quot;, 80))&#10;        # Get the local IP address that the socket is using.&#10;        ip = s.getsockname()[0]&#10;        # Close the socket.&#10;        s.close()&#10;    except Exception:&#10;        # If something goes wrong (for example: no internet connection),&#10;        # return a default IP address as a fallback.&#10;        s.close()&#10;        ip = &quot;26.113.0.164&quot;&#10;&#10;    # Return the detected local IP address.&#10;    return ip&#10;&#10;def broadcast_offers(server_tcp_port):&#10;    &quot;&quot;&quot;&#10;    Broadcasts UDP offers every 1 second.&#10;    Thread-safe logging via logger.&#10;    &quot;&quot;&quot;&#10;    # Create a UDP socket for sending broadcast messages.&#10;    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)&#10;    # Allows the socket to send packets to the broadcast address.&#10;    udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)&#10;&#10;    try:&#10;        while True:&#10;            # The packet contains the TCP port and the server name.&#10;            packet = protocol.pack_offer(server_tcp_port, &quot;Dekel-Sagi-Server&quot;)&#10;            # Send the offer packet to all devices in the local network&#10;            # using the broadcast IP and the predefined UDP port.&#10;            udp_socket.sendto(packet, (BROADCAST_IP, UDP_DEST_PORT))&#10;            time.sleep(1)&#10;    except Exception as e:&#10;        logger.error(f&quot;Error in broadcast thread: {e}&quot;)&#10;    finally:&#10;        udp_socket.close()&#10;&#10;&#10;def send_game_packet(sock, result, card):&#10;    &quot;&quot;&quot;&#10;    Helper function to pack and send a game payload message.&#10;    &quot;&quot;&quot;&#10;    rank, suit = card&#10;    packet = protocol.pack_server_payload(result, rank, suit)&#10;    sock.sendall(packet)&#10;&#10;&#10;def calculate_points_safe(cards):&#10;    &quot;&quot;&quot;&#10;    Internal helper to calculate hand value safely.&#10;    Prevents logic errors if the external game library behaves unexpectedly.&#10;    &quot;&quot;&quot;&#10;    total = 0&#10;    aces = 0&#10;    for card in cards:&#10;        rank = card[0]&#10;        if rank == 1:  # Ace&#10;            aces += 1&#10;            total += 11&#10;        elif rank &gt;= 10:  # Face cards&#10;            total += 10&#10;        else:&#10;            total += rank&#10;&#10;    # Handle Aces&#10;    while total &gt; 21 and aces &gt; 0:&#10;        total -= 10&#10;        aces -= 1&#10;    return total&#10;&#10;&#10;&#10;def drain_socket(sock):&#10;    &quot;&quot;&quot;&#10;    Clears any pending data in the socket buffer.&#10;    Prevents 'Ghost Commands' from previous rounds.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        sock.setblocking(False)&#10;        while sock.recv(1024):&#10;            pass&#10;    except:&#10;        pass&#10;    finally:&#10;        sock.setblocking(True)&#10;&#10;&#10;def play_one_round(client_socket, game_num, client_name, client_addr):&#10;&#10;    drain_socket(client_socket)&#10;    time.sleep(0.8)&#10;&#10;    game = BlackjackGame()&#10;    player_cards = []&#10;    dealer_cards = []&#10;&#10;    log_prefix = f&quot;[{client_name} | {client_addr[0]}:{client_addr[1]}]&quot;&#10;    logger.info(f&quot;{log_prefix} Starting Round {game_num}&quot;)&#10;&#10;    # 1. Initial Deal&#10;    player_cards.append(game.draw_card())&#10;    player_cards.append(game.draw_card())&#10;    dealer_cards.append(game.draw_card())&#10;    dealer_cards.append(game.draw_card())&#10;&#10;    send_game_packet(client_socket, 0, player_cards[0])&#10;    time.sleep(0.2)&#10;    send_game_packet(client_socket, 0, player_cards[1])&#10;    time.sleep(0.2)&#10;    send_game_packet(client_socket, 0, dealer_cards[0])&#10;    time.sleep(0.2)&#10;&#10;    # 2. Player Turn&#10;    player_bust = False&#10;    while True:&#10;        if calculate_points_safe(player_cards) &gt;= 21:&#10;            break&#10;&#10;        try:&#10;            client_socket.settimeout(CLIENT_TIMEOUT)&#10;            data = client_socket.recv(1024)&#10;            client_socket.settimeout(None)&#10;&#10;            if not data: raise Exception(&quot;Client disconnected&quot;)&#10;&#10;            decision = protocol.unpack_client_payload(data)&#10;&#10;            if decision == &quot;Hittt&quot;:&#10;                new_card = game.draw_card()&#10;                player_cards.append(new_card)&#10;                player_sum = calculate_points_safe(player_cards)&#10;&#10;                if player_sum &gt; 21:&#10;                    send_game_packet(client_socket, 2, new_card)&#10;                    logger.info(f&quot;{log_prefix} Player busted with {player_sum}!&quot;)&#10;                    logger.info(f&quot;{log_prefix} Round {game_num} finished. Result code: 2&quot;)&#10;                    return&#10;                else:&#10;                    send_game_packet(client_socket, 0, new_card)&#10;&#10;            elif decision == &quot;Stand&quot;:&#10;                logger.info(f&quot;{log_prefix} Player chose to Stand.&quot;)&#10;                break&#10;            else:&#10;                logger.debug(f&quot;{log_prefix} Received invalid packet/garbage. Ignoring.&quot;)&#10;                continue&#10;&#10;        except socket.timeout:&#10;            logger.warning(f&quot;{log_prefix} Timed out.&quot;)&#10;            raise Exception(&quot;Game Timeout&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;{log_prefix} Connection error: {e}&quot;)&#10;            raise e&#10;&#10;    # 3. Dealer Turn&#10;    dealer_sum = calculate_points_safe(dealer_cards)&#10;    logger.debug(f&quot;{log_prefix} Initial Dealer Hand: {dealer_cards} (Sum: {dealer_sum})&quot;)&#10;&#10;    if dealer_sum &lt; 17:&#10;        send_game_packet(client_socket, 0, dealer_cards[1])  # Reveal&#10;&#10;        while dealer_sum &lt; 17:&#10;            time.sleep(0.5)&#10;            new_card = game.draw_card()&#10;            dealer_cards.append(new_card)&#10;            dealer_sum = calculate_points_safe(dealer_cards)&#10;&#10;            logger.debug(f&quot;{log_prefix} Dealer drew {new_card}. New Sum: {dealer_sum}&quot;)&#10;&#10;            if dealer_sum &lt; 17:&#10;                send_game_packet(client_socket, 0, new_card)&#10;    else:&#10;        logger.info(f&quot;{log_prefix} Dealer stands on initial {dealer_sum}&quot;)&#10;&#10;    # 4. Result Logic&#10;    p_final = calculate_points_safe(player_cards)&#10;    d_final = calculate_points_safe(dealer_cards)&#10;&#10;    logger.debug(f&quot;{log_prefix} FINAL CALC -&gt; Player: {p_final}, Dealer: {d_final}&quot;)&#10;&#10;    winner = 0&#10;    if d_final &gt; 21:&#10;        winner = 3&#10;    elif p_final &gt; d_final:&#10;        winner = 3&#10;    elif d_final &gt; p_final:&#10;        winner = 2&#10;    else:&#10;        winner = 1&#10;&#10;    send_game_packet(client_socket, winner, dealer_cards[-1])&#10;    logger.info(f&quot;{log_prefix} Round {game_num} finished. Result code: {winner}&quot;)&#10;&#10;&#10;def handle_client(client_socket, client_addr):&#10;    &quot;&quot;&quot;&#10;    Handles a single client connection.&#10;    Updates global player statistics (thread-safe with lock).&#10;    Each client runs in its own thread from the thread pool.&#10;    &quot;&quot;&quot;&#10;    global active_players&#10;&#10;    # Update stats safely (Thread Safe)&#10;    with active_players_lock:&#10;        active_players += 1&#10;        current_players = active_players&#10;&#10;    logger.info(f&quot;New Connection: {client_addr[0]}:{client_addr[1]} | Total Players: {current_players}&quot;)&#10;&#10;    try:&#10;        # Handshake&#10;        client_socket.settimeout(CLIENT_TIMEOUT)&#10;        request_data = client_socket.recv(1024)&#10;        client_socket.settimeout(None)&#10;&#10;        valid_request = protocol.unpack_request(request_data)&#10;        if not valid_request:&#10;            logger.warning(f&quot;Invalid request from {client_addr}&quot;)&#10;            return&#10;&#10;        num_rounds, client_name = valid_request&#10;        logger.info(f&quot;Player '{client_name}' ({client_addr[0]}) wants {num_rounds} rounds&quot;)&#10;&#10;        # Game Loop&#10;        for i in range(num_rounds):&#10;            play_one_round(client_socket, i + 1, client_name, client_addr)&#10;            time.sleep(1.5)&#10;&#10;        logger.info(f&quot;Finished serving '{client_name}' at {client_addr[0]}&quot;)&#10;        time.sleep(2.0)&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Error serving {client_addr}: {e}&quot;)&#10;    finally:&#10;        # Update stats safely on exit&#10;        with active_players_lock:&#10;            active_players -= 1&#10;            remaining = active_players&#10;&#10;        logger.info(f&quot;Disconnected: {client_addr[0]}:{client_addr[1]} | Total Players: {remaining}&quot;)&#10;        client_socket.close()&#10;&#10;&#10;def start_server():&#10;    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&#10;    server_socket.bind(('0.0.0.0', TCP_PORT))&#10;    server_tcp_port = server_socket.getsockname()[1]&#10;    server_socket.listen()&#10;&#10;    logger.info(f&quot;Server started on IP {get_local_ip()}&quot;)&#10;    logger.info(f&quot;Listening on TCP port {server_tcp_port}&quot;)&#10;    logger.info(f&quot;Thread pool max workers: {MAX_CONCURRENT_CLIENTS}&quot;)&#10;    logger.info(&quot;Waiting for clients...&quot;)&#10;&#10;    server_socket.settimeout(1.0)&#10;&#10;    broadcast_thread = threading.Thread(target=broadcast_offers, args=(server_tcp_port,), daemon=True, name=&quot;BroadcastThread&quot;)&#10;    broadcast_thread.daemon = True&#10;    broadcast_thread.start()&#10;&#10;    try:&#10;        while True:&#10;            try:&#10;                client_sock, client_addr = server_socket.accept()&#10;                # Submit client handling to thread pool instead of creating new threads&#10;                thread_pool.submit(handle_client, client_sock, client_addr)&#10;&#10;            except socket.timeout:&#10;                continue&#10;            except Exception as e:&#10;                logger.error(f&quot;Server error: {e}&quot;)&#10;                break&#10;    finally:&#10;        logger.info(&quot;Shutting down thread pool...&quot;)&#10;        thread_pool.shutdown(wait=True)&#10;        server_socket.close()&#10;        logger.info(&quot;Server stopped&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    start_server()" />
              <option name="updatedContent" value="import socket&#10;import time&#10;import threading&#10;import protocol&#10;from game_logic import BlackjackGame&#10;from concurrent.futures import ThreadPoolExecutor&#10;import logging&#10;&#10;# --- Logging Setup ---&#10;logging.basicConfig(&#10;    level=logging.INFO,&#10;    format='%(asctime)s [%(threadName)-12s] %(message)s',&#10;    datefmt='%H:%M:%S'&#10;)&#10;logger = logging.getLogger(__name__)&#10;&#10;# --- Network Constants ---&#10;UDP_DEST_PORT = 13122&#10;BROADCAST_IP = '&lt;broadcast&gt;'&#10;TCP_PORT = 0&#10;CLIENT_TIMEOUT = 60&#10;MAX_CONCURRENT_CLIENTS = 10  # Thread pool size&#10;&#10;# --- Global Statistics (Thread-Safe) ---&#10;active_players = 0&#10;active_players_lock = threading.Lock()&#10;&#10;# --- Thread Pool ---&#10;thread_pool = ThreadPoolExecutor(max_workers=MAX_CONCURRENT_CLIENTS, thread_name_prefix=&quot;ClientHandler&quot;)&#10;&#10;&#10;def get_local_ip():&#10;    &quot;&quot;&quot;&#10;    Attempts to find the actual local IP address of the machine.&#10;    &quot;&quot;&quot;&#10;    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)&#10;    try:&#10;        # Create UDP socket&#10;        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)&#10;        s.connect((&quot;8.8.8.8&quot;, 80))&#10;        # Get the local IP address that the socket is using.&#10;        ip = s.getsockname()[0]&#10;        # Close the socket.&#10;        s.close()&#10;    except Exception:&#10;        # If something goes wrong (for example: no internet connection),&#10;        # return a default IP address as a fallback.&#10;        s.close()&#10;        ip = &quot;26.113.0.164&quot;&#10;&#10;    # Return the detected local IP address.&#10;    return ip&#10;&#10;def broadcast_offers(server_tcp_port):&#10;    &quot;&quot;&quot;&#10;    Broadcasts UDP offers every 1 second.&#10;    Thread-safe logging via logger.&#10;    &quot;&quot;&quot;&#10;    # Create a UDP socket for sending broadcast messages.&#10;    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)&#10;    # Allows the socket to send packets to the broadcast address.&#10;    udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)&#10;&#10;    try:&#10;        while True:&#10;            # The packet contains the TCP port and the server name.&#10;            packet = protocol.pack_offer(server_tcp_port, &quot;Dekel-Sagi-Server&quot;)&#10;            # Send the offer packet to all devices in the local network&#10;            # using the broadcast IP and the predefined UDP port.&#10;            udp_socket.sendto(packet, (BROADCAST_IP, UDP_DEST_PORT))&#10;            time.sleep(1)&#10;    except Exception as e:&#10;        logger.error(f&quot;Error in broadcast thread: {e}&quot;)&#10;    finally:&#10;        udp_socket.close()&#10;&#10;&#10;def send_game_packet(sock, result, card):&#10;    &quot;&quot;&quot;&#10;    Helper function to pack and send a game payload message.&#10;    &quot;&quot;&quot;&#10;    rank, suit = card&#10;    packet = protocol.pack_server_payload(result, rank, suit)&#10;    sock.sendall(packet)&#10;&#10;&#10;def calculate_points_safe(cards):&#10;    &quot;&quot;&quot;&#10;    Internal helper to calculate hand value safely.&#10;    Prevents logic errors if the external game library behaves unexpectedly.&#10;    &quot;&quot;&quot;&#10;    total = 0&#10;    aces = 0&#10;    for card in cards:&#10;        rank = card[0]&#10;        if rank == 1:  # Ace&#10;            aces += 1&#10;            total += 11&#10;        elif rank &gt;= 10:  # Face cards&#10;            total += 10&#10;        else:&#10;            total += rank&#10;&#10;    # Handle Aces&#10;    while total &gt; 21 and aces &gt; 0:&#10;        total -= 10&#10;        aces -= 1&#10;    return total&#10;&#10;&#10;&#10;def drain_socket(sock):&#10;    &quot;&quot;&quot;&#10;    Clears any pending data in the socket buffer.&#10;    Prevents 'Ghost Commands' from previous rounds.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        sock.setblocking(False)&#10;        while sock.recv(1024):&#10;            pass&#10;    except:&#10;        pass&#10;    finally:&#10;        sock.setblocking(True)&#10;&#10;&#10;def play_one_round(client_socket, game_num, client_name, client_addr):&#10;&#10;    drain_socket(client_socket)&#10;    time.sleep(0.8)&#10;&#10;    game = BlackjackGame()&#10;    player_cards = []&#10;    dealer_cards = []&#10;&#10;    log_prefix = f&quot;[{client_name} | {client_addr[0]}:{client_addr[1]}]&quot;&#10;    logger.info(f&quot;{log_prefix} Starting Round {game_num}&quot;)&#10;&#10;    # 1. Initial Deal&#10;    player_cards.append(game.draw_card())&#10;    player_cards.append(game.draw_card())&#10;    dealer_cards.append(game.draw_card())&#10;    dealer_cards.append(game.draw_card())&#10;&#10;    send_game_packet(client_socket, 0, player_cards[0])&#10;    time.sleep(0.2)&#10;    send_game_packet(client_socket, 0, player_cards[1])&#10;    time.sleep(0.2)&#10;    send_game_packet(client_socket, 0, dealer_cards[0])&#10;    time.sleep(0.2)&#10;&#10;    # 2. Player Turn&#10;    player_bust = False&#10;    while True:&#10;        if calculate_points_safe(player_cards) &gt;= 21:&#10;            break&#10;&#10;        try:&#10;            client_socket.settimeout(CLIENT_TIMEOUT)&#10;            data = client_socket.recv(1024)&#10;            client_socket.settimeout(None)&#10;&#10;            if not data: raise Exception(&quot;Client disconnected&quot;)&#10;&#10;            decision = protocol.unpack_client_payload(data)&#10;&#10;            if decision == &quot;Hittt&quot;:&#10;                new_card = game.draw_card()&#10;                player_cards.append(new_card)&#10;                player_sum = calculate_points_safe(player_cards)&#10;&#10;                if player_sum &gt; 21:&#10;                    send_game_packet(client_socket, 2, new_card)&#10;                    logger.info(f&quot;{log_prefix} Player busted with {player_sum}!&quot;)&#10;                    logger.info(f&quot;{log_prefix} Round {game_num} finished. Result code: 2&quot;)&#10;                    return&#10;                else:&#10;                    send_game_packet(client_socket, 0, new_card)&#10;&#10;            elif decision == &quot;Stand&quot;:&#10;                logger.info(f&quot;{log_prefix} Player chose to Stand.&quot;)&#10;                break&#10;            else:&#10;                logger.debug(f&quot;{log_prefix} Received invalid packet/garbage. Ignoring.&quot;)&#10;                continue&#10;&#10;        except socket.timeout:&#10;            logger.warning(f&quot;{log_prefix} Timed out.&quot;)&#10;            raise Exception(&quot;Game Timeout&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;{log_prefix} Connection error: {e}&quot;)&#10;            raise e&#10;&#10;    # 3. Dealer Turn&#10;    dealer_sum = calculate_points_safe(dealer_cards)&#10;    logger.debug(f&quot;{log_prefix} Initial Dealer Hand: {dealer_cards} (Sum: {dealer_sum})&quot;)&#10;&#10;    if dealer_sum &lt; 17:&#10;        send_game_packet(client_socket, 0, dealer_cards[1])  # Reveal&#10;&#10;        while dealer_sum &lt; 17:&#10;            time.sleep(0.5)&#10;            new_card = game.draw_card()&#10;            dealer_cards.append(new_card)&#10;            dealer_sum = calculate_points_safe(dealer_cards)&#10;&#10;            logger.debug(f&quot;{log_prefix} Dealer drew {new_card}. New Sum: {dealer_sum}&quot;)&#10;&#10;            if dealer_sum &lt; 17:&#10;                send_game_packet(client_socket, 0, new_card)&#10;    else:&#10;        logger.info(f&quot;{log_prefix} Dealer stands on initial {dealer_sum}&quot;)&#10;&#10;    # 4. Result Logic&#10;    p_final = calculate_points_safe(player_cards)&#10;    d_final = calculate_points_safe(dealer_cards)&#10;&#10;    logger.debug(f&quot;{log_prefix} FINAL CALC -&gt; Player: {p_final}, Dealer: {d_final}&quot;)&#10;&#10;    winner = 0&#10;    if d_final &gt; 21:&#10;        winner = 3&#10;    elif p_final &gt; d_final:&#10;        winner = 3&#10;    elif d_final &gt; p_final:&#10;        winner = 2&#10;    else:&#10;        winner = 1&#10;&#10;    send_game_packet(client_socket, winner, dealer_cards[-1])&#10;    logger.info(f&quot;{log_prefix} Round {game_num} finished. Result code: {winner}&quot;)&#10;&#10;&#10;def handle_client(client_socket, client_addr):&#10;    &quot;&quot;&quot;&#10;    Handles a single client connection.&#10;    Updates global player statistics (thread-safe with lock).&#10;    Each client runs in its own thread from the thread pool.&#10;    &quot;&quot;&quot;&#10;    global active_players&#10;&#10;    # Update stats safely (Thread Safe)&#10;    with active_players_lock:&#10;        active_players += 1&#10;        current_players = active_players&#10;&#10;    logger.info(f&quot;New Connection: {client_addr[0]}:{client_addr[1]} | Total Players: {current_players}&quot;)&#10;&#10;    try:&#10;        # Handshake&#10;        client_socket.settimeout(CLIENT_TIMEOUT)&#10;        request_data = client_socket.recv(1024)&#10;        client_socket.settimeout(None)&#10;&#10;        valid_request = protocol.unpack_request(request_data)&#10;        if not valid_request:&#10;            logger.warning(f&quot;Invalid request from {client_addr}&quot;)&#10;            return&#10;&#10;        num_rounds, client_name = valid_request&#10;        logger.info(f&quot;Player '{client_name}' ({client_addr[0]}) wants {num_rounds} rounds&quot;)&#10;&#10;        # Game Loop&#10;        for i in range(num_rounds):&#10;            play_one_round(client_socket, i + 1, client_name, client_addr)&#10;            time.sleep(1.5)&#10;&#10;        logger.info(f&quot;Finished serving '{client_name}' at {client_addr[0]}&quot;)&#10;        time.sleep(2.0)&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Error serving {client_addr}: {e}&quot;)&#10;    finally:&#10;        # Update stats safely on exit&#10;        with active_players_lock:&#10;            active_players -= 1&#10;            remaining = active_players&#10;&#10;        logger.info(f&quot;Disconnected: {client_addr[0]}:{client_addr[1]} | Total Players: {remaining}&quot;)&#10;        client_socket.close()&#10;&#10;&#10;def start_server():&#10;    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&#10;    server_socket.bind(('0.0.0.0', TCP_PORT))&#10;    server_tcp_port = server_socket.getsockname()[1]&#10;    server_socket.listen()&#10;&#10;    logger.info(f&quot;Server started on IP {get_local_ip()}&quot;)&#10;    logger.info(f&quot;Listening on TCP port {server_tcp_port}&quot;)&#10;    logger.info(f&quot;Thread pool max workers: {MAX_CONCURRENT_CLIENTS}&quot;)&#10;    logger.info(&quot;Waiting for clients...&quot;)&#10;&#10;    server_socket.settimeout(1.0)&#10;&#10;    broadcast_thread = threading.Thread(target=broadcast_offers, args=(server_tcp_port,), daemon=True, name=&quot;BroadcastThread&quot;)&#10;    broadcast_thread.daemon = True&#10;    broadcast_thread.start()&#10;&#10;    try:&#10;        while True:&#10;            try:&#10;                client_sock, client_addr = server_socket.accept()&#10;                # Submit client handling to thread pool instead of creating new threads&#10;                thread_pool.submit(handle_client, client_sock, client_addr)&#10;&#10;            except socket.timeout:&#10;                continue&#10;            except Exception as e:&#10;                logger.error(f&quot;Server error: {e}&quot;)&#10;                break&#10;    finally:&#10;        logger.info(&quot;Shutting down thread pool...&quot;)&#10;        thread_pool.shutdown(wait=True)&#10;        server_socket.close()&#10;        logger.info(&quot;Server stopped&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    start_server()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>